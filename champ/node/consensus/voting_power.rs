use anyhow::{anyhow, Result};

use crate::consensus::graphs::*;
use crate::state::ChampStateArc;
use pog_proto::api;

// To balance each graph
const BLOCK_WEIGHT: f64 = 1.2;
const BALANCE_WEIGHT: f64 = 0.5;
const AGE_WEIGHT: f64 = 1.0;

// so we can normalize the network affect
const MAX_NETWORK_POWER: f64 = 0.3;

// Month in Seconds
const LOOKBACK_RANGE: u64 = 60 * 60 * 24 * 30;
// 2 Months in Seconds
const MAX_LOOKBACK_RANGE: u64 = 60 * 60 * 24 * 30 * 2;

/// Returns actual voting power of an account.
/// Actual voting power is without the delegated power.
pub async fn get_actual_power(state: &ChampStateArc, account_id: api::AccountID) -> Result<u32> {
    let db = &state.db.lock().await;

    let block = db.get_latest_block_by_account(account_id).await?;
    let data = block.data.as_ref().ok_or_else(|| anyhow!("block data not found"))?;

    // Block from between lookback range and max lookback range
    let old_block_result = db
        .get_latest_block_by_account_before(
            account_id,
            block.timestamp - LOOKBACK_RANGE,
            block.timestamp - MAX_LOOKBACK_RANGE,
        )
        .await?;

    // First Block from an account
    let first_block = db.get_block_by_height(account_id, &0).await?.ok_or_else(|| anyhow!("no block found"))?;

    let bresult = balance_graph(data.balance);
    let bbresult = block_graph(data.height, &block, old_block_result.as_ref());
    let aresult = age_graph(block.timestamp - first_block.timestamp);

    // TODO: Green Adresses?

    // Weights to change how much impact each factor should have
    let graph_result = bbresult * BLOCK_WEIGHT + bresult * BALANCE_WEIGHT + aresult * AGE_WEIGHT;

    let result = if graph_result < 0.0 {
        0
    } else {
        graph_result as u32
    };

    // Problem: Spamming new accounts that have a little value and are over a month old can increase a wallets
    // importance further than needed
    // Solution 1: Cap wallet importance at 10% or smth of network voting
    //      - Means that voting is no longer linier and less democratic
    //      - Decreases voting power for people who delegate to a trusted well known Wallet
    // Solution 2: Cap Age_graph at a max to decrease age being a factor
    //      - Doesnt fully solve the problem only decreases ma voting generated by wallets
    // Solution 3: Cap Delegated power to a wallet
    //      - Discourages delegating to a wallet with power even though its a good wallet
    //      - Makes voting less democratic as some wallets will delegate decreased voting power
    //      - Evens out all voting over more nodes
    //      - Encourages looking at other wallets ideas
    //      - More "Parties" might mean more voting
    // Solution 4: Create algorithm to decide if wallets are for "farming voting" or actual wallets
    //      - Really hard to do as algo needs to be high end
    //      - Probably work around can be found as wallet info is limited
    //      - Can flag wrong accounts as "farmers"
    // Solution 5: Delegating voting only to a node not a wallet
    //      - Less direct representative if multiple prime delegates on a node and therefore less suseptible to farming
    //      - Will change everything
    //      - If multiple Prime Delegates on a node, split the voting power
    //      - Doesnt solve the problem if its one Prime Delegate per node
    // Solution 6: Have hidden ID when creating wallets to see who creates wallets
    //      - Can be used to decide if a wallet is farming (ties in to solution 4)
    //      - Less private and adds layer of 1984 style observation
    //      - Can probably be easily countered
    // Solution 7: Have block_graph go negative to force blocks being published
    //      - Makes it harder to farm because increased effort
    //      - Farmers can still send each other blocks to increase importance
    //      - Encourages trading which increases voting so better to farm
    //      - Adds data that to decide if a wallet is farming (ties in to solution 4)
    // Solution 8: Reduce Balance weight but uncap Balance graph and increase block_graph weight
    //      - Encourages having only one account
    //      - Encourages having transactions
    // Solution 9: Increase importance with increasing SendTrx but uncap balance
    //      - Encourages having more money
    //      - Encourages activlly losing money

    Ok(result)
}

/// Gets the sum of the power of each delegate of an account
async fn get_delegated_power(state: &ChampStateArc, account_id: api::AccountID) -> Result<u32> {
    // TODO: Cache this
    let mut power = 0;
    let db = &state.db.lock().await;

    let mut delegates = db.get_delegates_by_account(account_id).await?;
    // TODO: Test Performance and do this concurrently?
    while let Some(d) = delegates.pop() {
        let p = get_actual_power(state, d.to_owned()).await?;
        power += p;
    }

    Ok(power)
}

/// Returns the active power of an account that is being used on the network.
/// Active power is the account power with the delegated power.
pub async fn get_active_power(state: &ChampStateArc, account_id: api::AccountID) -> Result<u32> {
    let actual_power = get_actual_power(state, account_id).await?;
    let delegate_power = get_delegated_power(state, account_id).await?;
    let total_network_power = get_max_voting_power();
    let total_power = actual_power + delegate_power;
    if total_power > total_network_power {
        return Ok(total_network_power);
    }
    Ok(total_power)
}

/// Gets the max voting power in the system and sets a limit of a percentage
fn get_max_voting_power() -> u32 {
    //TODO: Get all voting power of all prime delegates combined
    let total_prime_delegate_power = 100_000_000_f64;
    (total_prime_delegate_power * MAX_NETWORK_POWER) as u32
}
